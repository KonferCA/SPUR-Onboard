// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: projects.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectTag = `-- name: AddProjectTag :one
INSERT INTO project_tags (
    project_id,
    tag_id
) VALUES (
    $1, $2
)
RETURNING id, project_id, tag_id, created_at
`

type AddProjectTagParams struct {
	ProjectID string
	TagID     string
}

func (q *Queries) AddProjectTag(ctx context.Context, arg AddProjectTagParams) (ProjectTag, error) {
	row := q.db.QueryRow(ctx, addProjectTag, arg.ProjectID, arg.TagID)
	var i ProjectTag
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TagID,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    company_id,
    title,
    description,
    status
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, company_id, title, description, status, created_at, updated_at
`

type CreateProjectParams struct {
	CompanyID   string
	Title       string
	Description *string
	Status      string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.CompanyID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectComment = `-- name: CreateProjectComment :one
INSERT INTO project_comments (
    project_id,
    user_id,
    comment
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, user_id, comment, created_at, updated_at
`

type CreateProjectCommentParams struct {
	ProjectID string
	UserID    string
	Comment   string
}

func (q *Queries) CreateProjectComment(ctx context.Context, arg CreateProjectCommentParams) (ProjectComment, error) {
	row := q.db.QueryRow(ctx, createProjectComment, arg.ProjectID, arg.UserID, arg.Comment)
	var i ProjectComment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectFile = `-- name: CreateProjectFile :one
INSERT INTO project_files (
    project_id,
    file_type,
    file_url
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, file_type, file_url, created_at, updated_at
`

type CreateProjectFileParams struct {
	ProjectID string
	FileType  string
	FileUrl   string
}

func (q *Queries) CreateProjectFile(ctx context.Context, arg CreateProjectFileParams) (ProjectFile, error) {
	row := q.db.QueryRow(ctx, createProjectFile, arg.ProjectID, arg.FileType, arg.FileUrl)
	var i ProjectFile
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileType,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectLink = `-- name: CreateProjectLink :one
INSERT INTO project_links (
    project_id,
    link_type,
    url
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, link_type, url, created_at, updated_at
`

type CreateProjectLinkParams struct {
	ProjectID string
	LinkType  string
	Url       string
}

func (q *Queries) CreateProjectLink(ctx context.Context, arg CreateProjectLinkParams) (ProjectLink, error) {
	row := q.db.QueryRow(ctx, createProjectLink, arg.ProjectID, arg.LinkType, arg.Url)
	var i ProjectLink
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.LinkType,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectQuestion = `-- name: CreateProjectQuestion :one
INSERT INTO project_questions (
    section_id,
    question_text,
    answer_text
) VALUES (
    $1, $2, $3
)
RETURNING id, section_id, question_text, answer_text, created_at, updated_at
`

type CreateProjectQuestionParams struct {
	SectionID    string
	QuestionText string
	AnswerText   string
}

func (q *Queries) CreateProjectQuestion(ctx context.Context, arg CreateProjectQuestionParams) (ProjectQuestion, error) {
	row := q.db.QueryRow(ctx, createProjectQuestion, arg.SectionID, arg.QuestionText, arg.AnswerText)
	var i ProjectQuestion
	err := row.Scan(
		&i.ID,
		&i.SectionID,
		&i.QuestionText,
		&i.AnswerText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectSection = `-- name: CreateProjectSection :one
INSERT INTO project_sections (
    project_id,
    title
) VALUES (
    $1, $2
)
RETURNING id, project_id, title, created_at, updated_at
`

type CreateProjectSectionParams struct {
	ProjectID string
	Title     string
}

func (q *Queries) CreateProjectSection(ctx context.Context, arg CreateProjectSectionParams) (ProjectSection, error) {
	row := q.db.QueryRow(ctx, createProjectSection, arg.ProjectID, arg.Title)
	var i ProjectSection
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllProjectTags = `-- name: DeleteAllProjectTags :exec
DELETE FROM project_tags 
WHERE project_id = $1
`

func (q *Queries) DeleteAllProjectTags(ctx context.Context, projectID string) error {
	_, err := q.db.Exec(ctx, deleteAllProjectTags, projectID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteProjectComment = `-- name: DeleteProjectComment :exec
DELETE FROM project_comments
WHERE id = $1
`

func (q *Queries) DeleteProjectComment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProjectComment, id)
	return err
}

const deleteProjectFile = `-- name: DeleteProjectFile :exec
DELETE FROM project_files
WHERE id = $1
`

func (q *Queries) DeleteProjectFile(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProjectFile, id)
	return err
}

const deleteProjectLink = `-- name: DeleteProjectLink :exec
DELETE FROM project_links
WHERE id = $1
`

func (q *Queries) DeleteProjectLink(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProjectLink, id)
	return err
}

const deleteProjectTag = `-- name: DeleteProjectTag :exec
DELETE FROM project_tags 
WHERE project_id = $1 AND tag_id = $2
`

type DeleteProjectTagParams struct {
	ProjectID string
	TagID     string
}

func (q *Queries) DeleteProjectTag(ctx context.Context, arg DeleteProjectTagParams) error {
	_, err := q.db.Exec(ctx, deleteProjectTag, arg.ProjectID, arg.TagID)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, company_id, title, description, status, created_at, updated_at FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id string) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectComments = `-- name: GetProjectComments :many
SELECT 
    pc.id, pc.project_id, pc.user_id, pc.comment, pc.created_at, pc.updated_at,
    u.first_name,
    u.last_name,
    u.email
FROM project_comments pc
JOIN users u ON u.id = pc.user_id
WHERE pc.project_id = $1
ORDER BY pc.created_at DESC
`

type GetProjectCommentsRow struct {
	ID        string
	ProjectID string
	UserID    string
	Comment   string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	FirstName *string
	LastName  *string
	Email     string
}

func (q *Queries) GetProjectComments(ctx context.Context, projectID string) ([]GetProjectCommentsRow, error) {
	rows, err := q.db.Query(ctx, getProjectComments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectCommentsRow
	for rows.Next() {
		var i GetProjectCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectFiles = `-- name: ListProjectFiles :many
SELECT id, project_id, file_type, file_url, created_at, updated_at FROM project_files
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectFiles(ctx context.Context, projectID string) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, listProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectFile
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileType,
			&i.FileUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectLinks = `-- name: ListProjectLinks :many
SELECT id, project_id, link_type, url, created_at, updated_at FROM project_links
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectLinks(ctx context.Context, projectID string) ([]ProjectLink, error) {
	rows, err := q.db.Query(ctx, listProjectLinks, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectLink
	for rows.Next() {
		var i ProjectLink
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.LinkType,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectTags = `-- name: ListProjectTags :many
SELECT 
    pt.id, pt.project_id, pt.tag_id, pt.created_at,
    t.name as tag_name
FROM project_tags pt
JOIN tags t ON t.id = pt.tag_id
WHERE pt.project_id = $1
ORDER BY t.name
`

type ListProjectTagsRow struct {
	ID        string
	ProjectID string
	TagID     string
	CreatedAt pgtype.Timestamp
	TagName   string
}

func (q *Queries) ListProjectTags(ctx context.Context, projectID string) ([]ListProjectTagsRow, error) {
	rows, err := q.db.Query(ctx, listProjectTags, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectTagsRow
	for rows.Next() {
		var i ListProjectTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TagID,
			&i.CreatedAt,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectWithDetails = `-- name: ListProjectWithDetails :one
SELECT 
    p.id, p.company_id, p.title, p.description, p.status, p.created_at, p.updated_at,
    c.name as company_name,
    c.industry as company_industry,
    c.founded_date as company_founded_date,
    c.company_stage as company_stage,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', ps.id,
                'title', ps.title,
                'questions', (
                    SELECT COALESCE(
                        json_agg(
                            jsonb_build_object(
                                'question', pq.question_text,
                                'answer', pq.answer_text
                            )
                        ),
                        '[]'::json
                    )
                    FROM project_questions pq
                    WHERE pq.section_id = ps.id
                )
            )
            FILTER (WHERE ps.id IS NOT NULL)
        ),
        '[]'::json
    ) as sections,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', pf.id,
                'name', pf.file_type,
                'url', pf.file_url
            )
            FILTER (WHERE pf.id IS NOT NULL)
        ),
        '[]'::json
    ) as documents
FROM projects p
LEFT JOIN companies c ON p.company_id = c.id
LEFT JOIN project_sections ps ON ps.project_id = p.id
LEFT JOIN project_files pf ON pf.project_id = p.id
WHERE p.id = $1
GROUP BY p.id, c.id
`

type ListProjectWithDetailsRow struct {
	ID                 string
	CompanyID          string
	Title              string
	Description        *string
	Status             string
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	CompanyName        *string
	CompanyIndustry    *string
	CompanyFoundedDate pgtype.Date
	CompanyStage       *string
	Sections           interface{}
	Documents          interface{}
}

func (q *Queries) ListProjectWithDetails(ctx context.Context, id string) (ListProjectWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, listProjectWithDetails, id)
	var i ListProjectWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompanyName,
		&i.CompanyIndustry,
		&i.CompanyFoundedDate,
		&i.CompanyStage,
		&i.Sections,
		&i.Documents,
	)
	return i, err
}

const listProjects = `-- name: ListProjects :many
SELECT 
    p.id, p.company_id, p.title, p.description, p.status, p.created_at, p.updated_at,
    c.name as company_name,
    c.industry as company_industry,
    c.founded_date as company_founded_date,
    c.company_stage as company_stage
FROM projects p
LEFT JOIN companies c ON p.company_id = c.id
ORDER BY p.created_at DESC
`

type ListProjectsRow struct {
	ID                 string
	CompanyID          string
	Title              string
	Description        *string
	Status             string
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	CompanyName        *string
	CompanyIndustry    *string
	CompanyFoundedDate pgtype.Date
	CompanyStage       *string
}

func (q *Queries) ListProjects(ctx context.Context) ([]ListProjectsRow, error) {
	rows, err := q.db.Query(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsRow
	for rows.Next() {
		var i ListProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
			&i.CompanyIndustry,
			&i.CompanyFoundedDate,
			&i.CompanyStage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByCompany = `-- name: ListProjectsByCompany :many
SELECT id, company_id, title, description, status, created_at, updated_at FROM projects
WHERE company_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectsByCompany(ctx context.Context, companyID string) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET 
    title = $2,
    description = $3,
    status = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, title, description, status, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          string
	Title       string
	Description *string
	Status      string
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
