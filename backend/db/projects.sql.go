// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: projects.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectTag = `-- name: AddProjectTag :one
INSERT INTO project_tags (
    project_id,
    tag_id
) VALUES (
    $1, $2
)
RETURNING id, project_id, tag_id, created_at
`

type AddProjectTagParams struct {
	ProjectID string
	TagID     string
}

func (q *Queries) AddProjectTag(ctx context.Context, arg AddProjectTagParams) (ProjectTag, error) {
	row := q.db.QueryRow(ctx, addProjectTag, arg.ProjectID, arg.TagID)
	var i ProjectTag
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TagID,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    company_id,
    title,
    description,
    status
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, company_id, title, description, status, created_at, updated_at
`

type CreateProjectParams struct {
	CompanyID   string
	Title       string
	Description *string
	Status      string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.CompanyID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectComment = `-- name: CreateProjectComment :one
INSERT INTO project_comments (
    project_id,
    user_id,
    comment
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, user_id, comment, created_at, updated_at
`

type CreateProjectCommentParams struct {
	ProjectID string
	UserID    string
	Comment   string
}

func (q *Queries) CreateProjectComment(ctx context.Context, arg CreateProjectCommentParams) (ProjectComment, error) {
	row := q.db.QueryRow(ctx, createProjectComment, arg.ProjectID, arg.UserID, arg.Comment)
	var i ProjectComment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectFile = `-- name: CreateProjectFile :one
INSERT INTO project_files (
    project_id,
    file_type,
    file_url
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, file_type, file_url, created_at, updated_at
`

type CreateProjectFileParams struct {
	ProjectID string
	FileType  string
	FileUrl   string
}

func (q *Queries) CreateProjectFile(ctx context.Context, arg CreateProjectFileParams) (ProjectFile, error) {
	row := q.db.QueryRow(ctx, createProjectFile, arg.ProjectID, arg.FileType, arg.FileUrl)
	var i ProjectFile
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileType,
		&i.FileUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectLink = `-- name: CreateProjectLink :one
INSERT INTO project_links (
    project_id,
    link_type,
    url
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, link_type, url, created_at, updated_at
`

type CreateProjectLinkParams struct {
	ProjectID string
	LinkType  string
	Url       string
}

func (q *Queries) CreateProjectLink(ctx context.Context, arg CreateProjectLinkParams) (ProjectLink, error) {
	row := q.db.QueryRow(ctx, createProjectLink, arg.ProjectID, arg.LinkType, arg.Url)
	var i ProjectLink
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.LinkType,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllProjectTags = `-- name: DeleteAllProjectTags :exec
DELETE FROM project_tags 
WHERE project_id = $1
`

func (q *Queries) DeleteAllProjectTags(ctx context.Context, projectID string) error {
	_, err := q.db.Exec(ctx, deleteAllProjectTags, projectID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteProjectComment = `-- name: DeleteProjectComment :exec
DELETE FROM project_comments
WHERE id = $1
`

func (q *Queries) DeleteProjectComment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProjectComment, id)
	return err
}

const deleteProjectFile = `-- name: DeleteProjectFile :exec
DELETE FROM project_files
WHERE id = $1
`

func (q *Queries) DeleteProjectFile(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProjectFile, id)
	return err
}

const deleteProjectLink = `-- name: DeleteProjectLink :exec
DELETE FROM project_links
WHERE id = $1
`

func (q *Queries) DeleteProjectLink(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProjectLink, id)
	return err
}

const deleteProjectTag = `-- name: DeleteProjectTag :exec
DELETE FROM project_tags 
WHERE project_id = $1 AND tag_id = $2
`

type DeleteProjectTagParams struct {
	ProjectID string
	TagID     string
}

func (q *Queries) DeleteProjectTag(ctx context.Context, arg DeleteProjectTagParams) error {
	_, err := q.db.Exec(ctx, deleteProjectTag, arg.ProjectID, arg.TagID)
	return err
}

const getProject = `-- name: GetProject :one
SELECT id, company_id, title, description, status, created_at, updated_at FROM projects
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id string) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectComments = `-- name: GetProjectComments :many
SELECT 
    pc.id, pc.project_id, pc.user_id, pc.comment, pc.created_at, pc.updated_at,
    u.first_name,
    u.last_name,
    u.email
FROM project_comments pc
JOIN users u ON u.id = pc.user_id
WHERE pc.project_id = $1
ORDER BY pc.created_at DESC
`

type GetProjectCommentsRow struct {
	ID        string
	ProjectID string
	UserID    string
	Comment   string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	FirstName *string
	LastName  *string
	Email     string
}

func (q *Queries) GetProjectComments(ctx context.Context, projectID string) ([]GetProjectCommentsRow, error) {
	rows, err := q.db.Query(ctx, getProjectComments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectCommentsRow
	for rows.Next() {
		var i GetProjectCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectFiles = `-- name: ListProjectFiles :many
SELECT id, project_id, file_type, file_url, created_at, updated_at FROM project_files
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectFiles(ctx context.Context, projectID string) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, listProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectFile
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileType,
			&i.FileUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectLinks = `-- name: ListProjectLinks :many
SELECT id, project_id, link_type, url, created_at, updated_at FROM project_links
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectLinks(ctx context.Context, projectID string) ([]ProjectLink, error) {
	rows, err := q.db.Query(ctx, listProjectLinks, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectLink
	for rows.Next() {
		var i ProjectLink
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.LinkType,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectTags = `-- name: ListProjectTags :many
SELECT 
    pt.id, pt.project_id, pt.tag_id, pt.created_at,
    t.name as tag_name
FROM project_tags pt
JOIN tags t ON t.id = pt.tag_id
WHERE pt.project_id = $1
ORDER BY t.name
`

type ListProjectTagsRow struct {
	ID        string
	ProjectID string
	TagID     string
	CreatedAt pgtype.Timestamp
	TagName   string
}

func (q *Queries) ListProjectTags(ctx context.Context, projectID string) ([]ListProjectTagsRow, error) {
	rows, err := q.db.Query(ctx, listProjectTags, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectTagsRow
	for rows.Next() {
		var i ListProjectTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TagID,
			&i.CreatedAt,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, company_id, title, description, status, created_at, updated_at FROM projects
ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByCompany = `-- name: ListProjectsByCompany :many
SELECT id, company_id, title, description, status, created_at, updated_at FROM projects
WHERE company_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectsByCompany(ctx context.Context, companyID string) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET 
    title = $2,
    description = $3,
    status = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, title, description, status, created_at, updated_at
`

type UpdateProjectParams struct {
	ID          string
	Title       string
	Description *string
	Status      string
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
