// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: company_financials.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompanyFinancials = `-- name: CreateCompanyFinancials :one
INSERT INTO company_financials (
    id,
    company_id,
    financial_year,
    revenue,
    expenses,
    profit,
    sales,
    amount_raised,
    arr,
    grants_received,
    created_at,
    updated_at
) VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
)
RETURNING id, company_id, financial_year, revenue, expenses, profit, sales, amount_raised, arr, grants_received, created_at, updated_at
`

type CreateCompanyFinancialsParams struct {
	CompanyID      string
	FinancialYear  int32
	Revenue        pgtype.Numeric
	Expenses       pgtype.Numeric
	Profit         pgtype.Numeric
	Sales          pgtype.Numeric
	AmountRaised   pgtype.Numeric
	Arr            pgtype.Numeric
	GrantsReceived pgtype.Numeric
}

func (q *Queries) CreateCompanyFinancials(ctx context.Context, arg CreateCompanyFinancialsParams) (CompanyFinancial, error) {
	row := q.db.QueryRow(ctx, createCompanyFinancials,
		arg.CompanyID,
		arg.FinancialYear,
		arg.Revenue,
		arg.Expenses,
		arg.Profit,
		arg.Sales,
		arg.AmountRaised,
		arg.Arr,
		arg.GrantsReceived,
	)
	var i CompanyFinancial
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.FinancialYear,
		&i.Revenue,
		&i.Expenses,
		&i.Profit,
		&i.Sales,
		&i.AmountRaised,
		&i.Arr,
		&i.GrantsReceived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCompanyFinancials = `-- name: DeleteCompanyFinancials :exec
DELETE FROM company_financials
WHERE company_id = $1 
AND financial_year = $2
`

type DeleteCompanyFinancialsParams struct {
	CompanyID     string
	FinancialYear int32
}

func (q *Queries) DeleteCompanyFinancials(ctx context.Context, arg DeleteCompanyFinancialsParams) error {
	_, err := q.db.Exec(ctx, deleteCompanyFinancials, arg.CompanyID, arg.FinancialYear)
	return err
}

const getCompanyFinancialsByYear = `-- name: GetCompanyFinancialsByYear :one
SELECT id, company_id, financial_year, revenue, expenses, profit, sales, amount_raised, arr, grants_received, created_at, updated_at
FROM company_financials
WHERE company_id = $1 
AND financial_year = $2
LIMIT 1
`

type GetCompanyFinancialsByYearParams struct {
	CompanyID     string
	FinancialYear int32
}

func (q *Queries) GetCompanyFinancialsByYear(ctx context.Context, arg GetCompanyFinancialsByYearParams) (CompanyFinancial, error) {
	row := q.db.QueryRow(ctx, getCompanyFinancialsByYear, arg.CompanyID, arg.FinancialYear)
	var i CompanyFinancial
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.FinancialYear,
		&i.Revenue,
		&i.Expenses,
		&i.Profit,
		&i.Sales,
		&i.AmountRaised,
		&i.Arr,
		&i.GrantsReceived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestCompanyFinancials = `-- name: GetLatestCompanyFinancials :one
SELECT id, company_id, financial_year, revenue, expenses, profit, sales, amount_raised, arr, grants_received, created_at, updated_at
FROM company_financials
WHERE company_id = $1
ORDER BY financial_year DESC
LIMIT 1
`

func (q *Queries) GetLatestCompanyFinancials(ctx context.Context, companyID string) (CompanyFinancial, error) {
	row := q.db.QueryRow(ctx, getLatestCompanyFinancials, companyID)
	var i CompanyFinancial
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.FinancialYear,
		&i.Revenue,
		&i.Expenses,
		&i.Profit,
		&i.Sales,
		&i.AmountRaised,
		&i.Arr,
		&i.GrantsReceived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCompanyFinancials = `-- name: ListCompanyFinancials :many
SELECT id, company_id, financial_year, revenue, expenses, profit, sales, amount_raised, arr, grants_received, created_at, updated_at
FROM company_financials
WHERE company_id = $1
ORDER BY financial_year DESC
`

func (q *Queries) ListCompanyFinancials(ctx context.Context, companyID string) ([]CompanyFinancial, error) {
	rows, err := q.db.Query(ctx, listCompanyFinancials, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompanyFinancial
	for rows.Next() {
		var i CompanyFinancial
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.FinancialYear,
			&i.Revenue,
			&i.Expenses,
			&i.Profit,
			&i.Sales,
			&i.AmountRaised,
			&i.Arr,
			&i.GrantsReceived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompanyFinancials = `-- name: UpdateCompanyFinancials :one
UPDATE company_financials
SET 
    revenue = $3,
    expenses = $4,
    profit = $5,
    sales = $6,
    amount_raised = $7,
    arr = $8,
    grants_received = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE company_id = $1 
AND financial_year = $2
RETURNING id, company_id, financial_year, revenue, expenses, profit, sales, amount_raised, arr, grants_received, created_at, updated_at
`

type UpdateCompanyFinancialsParams struct {
	CompanyID      string
	FinancialYear  int32
	Revenue        pgtype.Numeric
	Expenses       pgtype.Numeric
	Profit         pgtype.Numeric
	Sales          pgtype.Numeric
	AmountRaised   pgtype.Numeric
	Arr            pgtype.Numeric
	GrantsReceived pgtype.Numeric
}

func (q *Queries) UpdateCompanyFinancials(ctx context.Context, arg UpdateCompanyFinancialsParams) (CompanyFinancial, error) {
	row := q.db.QueryRow(ctx, updateCompanyFinancials,
		arg.CompanyID,
		arg.FinancialYear,
		arg.Revenue,
		arg.Expenses,
		arg.Profit,
		arg.Sales,
		arg.AmountRaised,
		arg.Arr,
		arg.GrantsReceived,
	)
	var i CompanyFinancial
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.FinancialYear,
		&i.Revenue,
		&i.Expenses,
		&i.Profit,
		&i.Sales,
		&i.AmountRaised,
		&i.Arr,
		&i.GrantsReceived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
