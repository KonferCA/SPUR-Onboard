// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: investment_intentions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateInvestmentIntentionStatus = `-- name: BulkUpdateInvestmentIntentionStatus :exec
UPDATE investment_intentions
SET 
    status = $2,
    updated_at = extract(epoch from now())
WHERE project_id = $1 AND status = $3
`

type BulkUpdateInvestmentIntentionStatusParams struct {
	ProjectID string           `json:"project_id"`
	Status    InvestmentStatus `json:"status"`
	Status_2  InvestmentStatus `json:"status_2"`
}

func (q *Queries) BulkUpdateInvestmentIntentionStatus(ctx context.Context, arg BulkUpdateInvestmentIntentionStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateInvestmentIntentionStatus, arg.ProjectID, arg.Status, arg.Status_2)
	return err
}

const createInvestmentIntention = `-- name: CreateInvestmentIntention :one
INSERT INTO investment_intentions (
    id,
    project_id,
    investor_id,
    intended_amount,
    status,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5,
    extract(epoch from now()),
    extract(epoch from now())
) RETURNING id, project_id, investor_id, intended_amount, status, transaction_hash, created_at, updated_at
`

type CreateInvestmentIntentionParams struct {
	ID             string           `json:"id"`
	ProjectID      string           `json:"project_id"`
	InvestorID     string           `json:"investor_id"`
	IntendedAmount pgtype.Numeric   `json:"intended_amount"`
	Status         InvestmentStatus `json:"status"`
}

func (q *Queries) CreateInvestmentIntention(ctx context.Context, arg CreateInvestmentIntentionParams) (InvestmentIntention, error) {
	row := q.db.QueryRow(ctx, createInvestmentIntention,
		arg.ID,
		arg.ProjectID,
		arg.InvestorID,
		arg.IntendedAmount,
		arg.Status,
	)
	var i InvestmentIntention
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.InvestorID,
		&i.IntendedAmount,
		&i.Status,
		&i.TransactionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvestmentIntention = `-- name: DeleteInvestmentIntention :exec
DELETE FROM investment_intentions
WHERE id = $1
`

func (q *Queries) DeleteInvestmentIntention(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvestmentIntention, id)
	return err
}

const getInvestmentIntentionByID = `-- name: GetInvestmentIntentionByID :one
SELECT 
    ii.id, ii.project_id, ii.investor_id, ii.intended_amount, ii.status, ii.transaction_hash, ii.created_at, ii.updated_at,
    u.first_name as investor_first_name,
    u.last_name as investor_last_name,
    u.email as investor_email,
    p.title as project_title,
    c.name as company_name
FROM investment_intentions ii
JOIN users u ON ii.investor_id = u.id
JOIN projects p ON ii.project_id = p.id
JOIN companies c ON p.company_id = c.id
WHERE ii.id = $1
`

type GetInvestmentIntentionByIDRow struct {
	ID                string           `json:"id"`
	ProjectID         string           `json:"project_id"`
	InvestorID        string           `json:"investor_id"`
	IntendedAmount    pgtype.Numeric   `json:"intended_amount"`
	Status            InvestmentStatus `json:"status"`
	TransactionHash   *string          `json:"transaction_hash"`
	CreatedAt         int64            `json:"created_at"`
	UpdatedAt         int64            `json:"updated_at"`
	InvestorFirstName *string          `json:"investor_first_name"`
	InvestorLastName  *string          `json:"investor_last_name"`
	InvestorEmail     string           `json:"investor_email"`
	ProjectTitle      string           `json:"project_title"`
	CompanyName       string           `json:"company_name"`
}

func (q *Queries) GetInvestmentIntentionByID(ctx context.Context, id string) (GetInvestmentIntentionByIDRow, error) {
	row := q.db.QueryRow(ctx, getInvestmentIntentionByID, id)
	var i GetInvestmentIntentionByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.InvestorID,
		&i.IntendedAmount,
		&i.Status,
		&i.TransactionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvestorFirstName,
		&i.InvestorLastName,
		&i.InvestorEmail,
		&i.ProjectTitle,
		&i.CompanyName,
	)
	return i, err
}

const getInvestmentIntentionsByInvestor = `-- name: GetInvestmentIntentionsByInvestor :many
SELECT 
    ii.id, ii.project_id, ii.investor_id, ii.intended_amount, ii.status, ii.transaction_hash, ii.created_at, ii.updated_at,
    p.title as project_title,
    c.name as company_name
FROM investment_intentions ii
JOIN projects p ON ii.project_id = p.id
JOIN companies c ON p.company_id = c.id
WHERE ii.investor_id = $1
ORDER BY ii.created_at DESC
`

type GetInvestmentIntentionsByInvestorRow struct {
	ID              string           `json:"id"`
	ProjectID       string           `json:"project_id"`
	InvestorID      string           `json:"investor_id"`
	IntendedAmount  pgtype.Numeric   `json:"intended_amount"`
	Status          InvestmentStatus `json:"status"`
	TransactionHash *string          `json:"transaction_hash"`
	CreatedAt       int64            `json:"created_at"`
	UpdatedAt       int64            `json:"updated_at"`
	ProjectTitle    string           `json:"project_title"`
	CompanyName     string           `json:"company_name"`
}

func (q *Queries) GetInvestmentIntentionsByInvestor(ctx context.Context, investorID string) ([]GetInvestmentIntentionsByInvestorRow, error) {
	rows, err := q.db.Query(ctx, getInvestmentIntentionsByInvestor, investorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvestmentIntentionsByInvestorRow
	for rows.Next() {
		var i GetInvestmentIntentionsByInvestorRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.InvestorID,
			&i.IntendedAmount,
			&i.Status,
			&i.TransactionHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectTitle,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvestmentIntentionsByProject = `-- name: GetInvestmentIntentionsByProject :many
SELECT 
    ii.id, ii.project_id, ii.investor_id, ii.intended_amount, ii.status, ii.transaction_hash, ii.created_at, ii.updated_at,
    u.first_name as investor_first_name,
    u.last_name as investor_last_name,
    u.email as investor_email
FROM investment_intentions ii
JOIN users u ON ii.investor_id = u.id
WHERE ii.project_id = $1
ORDER BY ii.created_at DESC
`

type GetInvestmentIntentionsByProjectRow struct {
	ID                string           `json:"id"`
	ProjectID         string           `json:"project_id"`
	InvestorID        string           `json:"investor_id"`
	IntendedAmount    pgtype.Numeric   `json:"intended_amount"`
	Status            InvestmentStatus `json:"status"`
	TransactionHash   *string          `json:"transaction_hash"`
	CreatedAt         int64            `json:"created_at"`
	UpdatedAt         int64            `json:"updated_at"`
	InvestorFirstName *string          `json:"investor_first_name"`
	InvestorLastName  *string          `json:"investor_last_name"`
	InvestorEmail     string           `json:"investor_email"`
}

func (q *Queries) GetInvestmentIntentionsByProject(ctx context.Context, projectID string) ([]GetInvestmentIntentionsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getInvestmentIntentionsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvestmentIntentionsByProjectRow
	for rows.Next() {
		var i GetInvestmentIntentionsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.InvestorID,
			&i.IntendedAmount,
			&i.Status,
			&i.TransactionHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InvestorFirstName,
			&i.InvestorLastName,
			&i.InvestorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvestmentIntentionsByProjectAndInvestor = `-- name: GetInvestmentIntentionsByProjectAndInvestor :one
SELECT id, project_id, investor_id, intended_amount, status, transaction_hash, created_at, updated_at
FROM investment_intentions
WHERE project_id = $1 AND investor_id = $2
`

type GetInvestmentIntentionsByProjectAndInvestorParams struct {
	ProjectID  string `json:"project_id"`
	InvestorID string `json:"investor_id"`
}

func (q *Queries) GetInvestmentIntentionsByProjectAndInvestor(ctx context.Context, arg GetInvestmentIntentionsByProjectAndInvestorParams) (InvestmentIntention, error) {
	row := q.db.QueryRow(ctx, getInvestmentIntentionsByProjectAndInvestor, arg.ProjectID, arg.InvestorID)
	var i InvestmentIntention
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.InvestorID,
		&i.IntendedAmount,
		&i.Status,
		&i.TransactionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvestmentIntentionsByStatus = `-- name: GetInvestmentIntentionsByStatus :many
SELECT 
    ii.id, ii.project_id, ii.investor_id, ii.intended_amount, ii.status, ii.transaction_hash, ii.created_at, ii.updated_at,
    u.first_name as investor_first_name,
    u.last_name as investor_last_name,
    u.email as investor_email,
    p.title as project_title,
    c.name as company_name
FROM investment_intentions ii
JOIN users u ON ii.investor_id = u.id
JOIN projects p ON ii.project_id = p.id
JOIN companies c ON p.company_id = c.id
WHERE ii.status = $1
ORDER BY ii.created_at DESC
`

type GetInvestmentIntentionsByStatusRow struct {
	ID                string           `json:"id"`
	ProjectID         string           `json:"project_id"`
	InvestorID        string           `json:"investor_id"`
	IntendedAmount    pgtype.Numeric   `json:"intended_amount"`
	Status            InvestmentStatus `json:"status"`
	TransactionHash   *string          `json:"transaction_hash"`
	CreatedAt         int64            `json:"created_at"`
	UpdatedAt         int64            `json:"updated_at"`
	InvestorFirstName *string          `json:"investor_first_name"`
	InvestorLastName  *string          `json:"investor_last_name"`
	InvestorEmail     string           `json:"investor_email"`
	ProjectTitle      string           `json:"project_title"`
	CompanyName       string           `json:"company_name"`
}

func (q *Queries) GetInvestmentIntentionsByStatus(ctx context.Context, status InvestmentStatus) ([]GetInvestmentIntentionsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getInvestmentIntentionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvestmentIntentionsByStatusRow
	for rows.Next() {
		var i GetInvestmentIntentionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.InvestorID,
			&i.IntendedAmount,
			&i.Status,
			&i.TransactionHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InvestorFirstName,
			&i.InvestorLastName,
			&i.InvestorEmail,
			&i.ProjectTitle,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalInvestmentIntentionsForProject = `-- name: GetTotalInvestmentIntentionsForProject :one
SELECT 
    COALESCE(SUM(intended_amount), 0) as total_amount,
    COUNT(*) as total_count
FROM investment_intentions
WHERE project_id = $1 AND status != 'cancelled'
`

type GetTotalInvestmentIntentionsForProjectRow struct {
	TotalAmount interface{} `json:"total_amount"`
	TotalCount  int64       `json:"total_count"`
}

func (q *Queries) GetTotalInvestmentIntentionsForProject(ctx context.Context, projectID string) (GetTotalInvestmentIntentionsForProjectRow, error) {
	row := q.db.QueryRow(ctx, getTotalInvestmentIntentionsForProject, projectID)
	var i GetTotalInvestmentIntentionsForProjectRow
	err := row.Scan(&i.TotalAmount, &i.TotalCount)
	return i, err
}

const updateInvestmentIntentionAmount = `-- name: UpdateInvestmentIntentionAmount :one
UPDATE investment_intentions
SET 
    intended_amount = $2,
    updated_at = extract(epoch from now())
WHERE id = $1
RETURNING id, project_id, investor_id, intended_amount, status, transaction_hash, created_at, updated_at
`

type UpdateInvestmentIntentionAmountParams struct {
	ID             string         `json:"id"`
	IntendedAmount pgtype.Numeric `json:"intended_amount"`
}

func (q *Queries) UpdateInvestmentIntentionAmount(ctx context.Context, arg UpdateInvestmentIntentionAmountParams) (InvestmentIntention, error) {
	row := q.db.QueryRow(ctx, updateInvestmentIntentionAmount, arg.ID, arg.IntendedAmount)
	var i InvestmentIntention
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.InvestorID,
		&i.IntendedAmount,
		&i.Status,
		&i.TransactionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvestmentIntentionStatus = `-- name: UpdateInvestmentIntentionStatus :one
UPDATE investment_intentions
SET 
    status = $2,
    transaction_hash = $3,
    updated_at = extract(epoch from now())
WHERE id = $1
RETURNING id, project_id, investor_id, intended_amount, status, transaction_hash, created_at, updated_at
`

type UpdateInvestmentIntentionStatusParams struct {
	ID              string           `json:"id"`
	Status          InvestmentStatus `json:"status"`
	TransactionHash *string          `json:"transaction_hash"`
}

func (q *Queries) UpdateInvestmentIntentionStatus(ctx context.Context, arg UpdateInvestmentIntentionStatusParams) (InvestmentIntention, error) {
	row := q.db.QueryRow(ctx, updateInvestmentIntentionStatus, arg.ID, arg.Status, arg.TransactionHash)
	var i InvestmentIntention
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.InvestorID,
		&i.IntendedAmount,
		&i.Status,
		&i.TransactionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
